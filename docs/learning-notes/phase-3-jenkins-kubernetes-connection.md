# Phase 3: Connecting Jenkins to Kubernetes

**Date:** 2026-02-25
**Files created/modified:**
- `jenkins/docker-compose.yml` — added minikube network + kubeconfig volume mount
- `jenkins/Dockerfile` — pre-created kubeconfig file to fix Docker mount behavior
- `jenkins/.env` — host path to kubeconfig (gitignored, environment-specific)
- `.gitignore` — added env files, kubeconfig patterns

---

## What we built

A persistent, reproducible connection between the Jenkins container and the
Minikube Kubernetes cluster, so that Jenkins pipelines can execute `kubectl`
commands against the local cluster.

---

## How it works

When a Jenkins pipeline runs a deployment stage, it calls `kubectl apply` or
`kubectl set image`. For kubectl to work inside the Jenkins container it needs:

1. **The kubectl binary** — installed in the Dockerfile
2. **Network access to the Kubernetes API server** — Jenkins container joined
   to the `minikube` Docker network
3. **A valid kubeconfig** — mounted from the host into the container

The flow on every `docker compose up`:

```
minikube start
  └── creates Docker network "minikube" (192.168.49.0/24)
      └── Minikube container gets IP 192.168.49.2
          └── Kubernetes API server listens on 192.168.49.2:8443

docker compose up
  └── Jenkins container starts
      └── joins "minikube" network (via docker-compose.yml)
      └── mounts ~/.kube/jenkins-kubeconfig → /root/.kube/jenkins-kubeconfig
      └── KUBECONFIG env var points kubectl to that file
          └── kubectl get nodes → talks to 192.168.49.2:8443 → SUCCESS
```

---

## Why the kubeconfig needed modification

The default kubeconfig generated by Minikube points to:
```
server: https://127.0.0.1:50393
```

`127.0.0.1` from inside the Jenkins container refers to Jenkins itself, not
the host. We replace it with Minikube's stable internal Docker network IP:
```
server: https://192.168.49.2:8443
```

The IP `192.168.49.2` is static — Minikube always assigns itself this address
on the `minikube` Docker network, regardless of restarts.

Command to regenerate the kubeconfig (run after `minikube delete && minikube start`):

```bash
kubectl config view --minify --flatten --context=minikube | \
  sed 's|server: https://127.0.0.1:[0-9]*|server: https://192.168.49.2:8443|' \
  > ~/.kube/jenkins-kubeconfig
```

---

## Startup order (important)

Always start in this order:

```bash
# 1. Start Minikube first — creates the "minikube" Docker network
minikube start

# 2. Then start Jenkins — joins the network declared in docker-compose.yml
cd jenkins/
docker compose up -d
```

If Jenkins starts before Minikube, `docker compose up` fails because the
external network `minikube` does not exist yet.

---

## Troubleshooting log

### Problem 1 — `docker: not found` in pipeline

**Symptom:** Pipeline fails with `exit code 127`, Docker binary not found.

**Root cause:** The Jenkins base image does not include the Docker CLI. Mounting
the Docker socket (`/var/run/docker.sock`) gives access to the daemon but not
the binary.

**Fix:** Install `docker.io` in the Dockerfile:
```dockerfile
RUN apt-get update && apt-get install -y docker.io
```

---

### Problem 2 — Jenkins could not reach Minikube API server

**Symptom:** `kubectl get nodes` failed with authentication errors and HTML
responses instead of JSON.

**Root cause (networking):** Jenkins and Minikube ran in separate Docker
networks. The kubeconfig pointed to `127.0.0.1`, which inside the Jenkins
container refers to Jenkins itself, not the host.

**Fix:**
1. Connect Jenkins to the `minikube` Docker network
2. Replace `127.0.0.1` with `192.168.49.2` (Minikube's static internal IP)
3. Declare the network as `external: true` in `docker-compose.yml`

---

### Problem 3 — `HOME=/root` mismatch

**Symptom:** kubectl ran but couldn't find the kubeconfig even though it was
copied to `/var/jenkins_home/.kube/config`.

**Root cause:** The container runs as `root` (required for Docker socket
access), so `HOME=/root`. kubectl looks for `$HOME/.kube/config` =
`/root/.kube/config`. The file was placed in the wrong directory.

**Fix:** Set the `KUBECONFIG` environment variable explicitly in
`docker-compose.yml` to point to the mounted file path.

---

### Problem 4 — Docker mounts file as directory

**Symptom:** `error loading config file: is a directory` — Docker created a
directory at the bind mount target instead of mounting the file.

**Root cause:** Docker creates the target path as a directory when it does not
already exist in the image. This happened because:
- On the host, a previous failed attempt left `~/.kube/jenkins-kubeconfig`
  as a directory (created by Docker itself in an earlier bad mount)
- Docker then tried to mount a directory onto a file path, causing the error

**Fix (two parts):**

1. On the host — remove the directory and recreate as a file:
```bash
sudo rm -rf ~/.kube/jenkins-kubeconfig
kubectl config view --minify --flatten --context=minikube | \
  sed 's|server: https://127.0.0.1:[0-9]*|server: https://192.168.49.2:8443|' \
  > ~/.kube/jenkins-kubeconfig
```

2. In the Dockerfile — pre-create the target as an empty file so Docker knows
the mount target is a file, not a directory:
```dockerfile
RUN mkdir -p /root/.kube && touch /root/.kube/jenkins-kubeconfig
```

---

## Architecture after Phase 3

```
WSL Host
├── ~/.kube/jenkins-kubeconfig     ← kubeconfig with 192.168.49.2:8443
│
├── Docker network: jenkins_default
│   └── jenkins container (:8080)
│
└── Docker network: minikube (192.168.49.0/24)
    ├── jenkins container            ← joined via docker-compose.yml
    │   ├── kubectl binary           ← installed in Dockerfile
    │   ├── KUBECONFIG env var       ← points to mounted kubeconfig
    │   └── /root/.kube/jenkins-kubeconfig  ← bind mount from host
    │
    └── minikube container (192.168.49.2)
        └── Kubernetes API server (:8443)
```

---

## What comes next

**Phase 4 — Kubernetes Manifests**

Write the Deployment and Service manifests for the 3D print app (FastAPI
backend + React frontend) and apply them to the cluster manually to verify
they work before hooking them into the Jenkins pipeline.
```
